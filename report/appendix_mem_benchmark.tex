\chapter{MEM Operation Benchmark}\label{apx:mem_benchmark}

\section{Forcing Cache Misses}

The cache misses making up the MEM operation, as explained in \autoref{chp4:subsec:MEM_operation}, were generated by running the code given in \autoref{lst:1k_cache_miss.c} in a time-bound loop.
Benchmarking the code, to verify the ability to forced increased amount of  suffered cache misses, was done by comparing the results of running this code with the results from the code given in \autoref{lst:1k_cache_hit.c}.
These two pieces of code only differ on one single line, namely line number $22$, where in \autoref{lst:1k_cache_miss.c} the random number is used for lookup, while in \autoref{lst:1k_cache_hit.c} the deterministic iteration counter is used.

\begin{lstinputlisting}[language=C, caption={1k\_cache\_miss.c - Force 1000 cache misses}, label={lst:1k_cache_miss.c}]{code/cachemiss.c}
\end{lstinputlisting}

\begin{lstinputlisting}[language=C, caption={1k\_cache\_hit.c - Cache miss reference}, label={lst:1k_cache_hit.c}]{code/cachehit.c}
\end{lstinputlisting}

\section{Collecting Results}

The data behind \autoref{fig:mem_benchmark} were generated by running the Python script given in \autoref{lst:benchmark_cache_misses.py} on both the target laptops.

\begin{lstinputlisting}[language=Python, caption={benchmark\_cache\_misses.py - Collect data from 1000 runs of the forced cache miss and reference benchmark utilities.}, label={lst:benchmark_cache_misses.py}]{code/benchmark_cache_misses.py}
\end{lstinputlisting}
