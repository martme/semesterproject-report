\chapter{Predictable Execution and Software for Analysiz}\label{chp:analyzing} 
Need reliable CPU activity to be able to relate acoustic fingerprint to CPU activity.
In this chapter we will discuss how we achieve this criteria while looking at multiple modes of operation for the microprocessor.
We will also look at how this setup is tailored to different architectures to achieve comparable results.

\section{Selection of Test Cases}
Introduction writing about the different test cases and reasoning behind choise
Write about how the test case functionality is wrapped in a deterministic pattern that can be analyzed in the time domain
Write about the content of the following sections (detailed proof of predictability in the cases, and expectations from the recorded audio fingerprint)

\section{CPU load}
Write about the cpuburn program and the shell wrapper program

\section{Microinstructions}
Write about the nop mem mul add loop util.
The implementation details for the ARM and x86 architectures

\subsection{Memory Access and Predictable Cache Miss}


\section{Decryption}
Write about the decryption util


\section{CPU microinstruction setup}\label{sec:ch4_cpu_microinstruction_setup}
Before jumping at RSA key extraction, we want to verify that we are able to distinguish the audio fingerprint created by a computer repreating microinstructions. 
The idea is that repeating the same microinstruction over a period of time should produce a distinct audio fingerprint identifying that microinstruction. 
However, the fingerprint is heavily dependent on the targeted hardware configuration. 
For this reason, we got our hands on a Lenovo ThinkPad T60p laptop computer, which is fairly similar in terms of how the computer is built and what hardware is used, so we expect there to be a higher probability of observing the suggested phenomenons using this computer.
\todo{Get a Evo N200!!!, see section 3 in paper}

The laptop is running Linux Mint 17, and starting out we compile and run the following program to repeat the microinstructions 

\begin{lstlisting}[language=C, caption={Simple Microinstruction Loop}]
// see http://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
// \lstinputlisting[language=C]{loop_operations.c}
int main() {
	return 0;
}
\end{lstlisting}


\subsection{Looking at microinstructions}\label{sec:ch4_microinstructions}
Initially, we did were repeating the instructions \( NOP\), \( MUL\) and \( ADD\).
As previously mentioned, our sampling rate of \( 96kHz\) limited our ability to observe the frequency spectrum of the signal to frequencies less than \( 48kHz\).
In this interval we were unable to emirically distinguish the spectrums representing the intervals in time corresponding to the different instructions.
This is not surprising, as the original research shows that there is no obvious visible difference in the frequency response of these three instructions in the frequency range we are observing, even on the laptop with the most rich acoustic leakage.\todo{Refer to Figure 7 in the long paper} 

On the other hand, the paper suggests that looking at HLT compared to NOP and MEM should produce a significant distinguisability even in the frequency range we are working with, given that the instructions are executed on an Evo N200 laptop.
The problem with this is that the HLT instruction must be run in kernel space.
For that reason we choose to focus on distinguishing between MEM and NOP, to be able to keep utilizing our simple setup, and avoid the troubles of kernel space programming.
