\chapter{Predictable Execution and Software for Analysis}\label{chp:analyzing} 
A prerequisite to analysis of acoustinc fingerprints is that you have some idea of what you are recording, and thus be able to look at the correlation between what is observed, and what was going on at the time.
In our case this means that we need to know what is going on in the CPU during the timespan of our recordings.
If we possess this knowledge, we should be more able draw conclusions regarding the correlation between what is observed in the acoustic fingerprint and distinct CPU activity.
This chapter will describe how we force predictable CPU activity, and also how we tailor the software run during the recordings for different architectures to achieve comparable results.

\section{Selection of Test Cases}
We will use several test cases, where the aim is to gradually record more and more subtle variations in CPU activity, and use this as a basis for our acoustic analysis.
We will start by oscilating between unnaturally high CPU loads and a minimal load, and eventually we will try to distinguish between the execution of the repeated execution of different distinct microinstructions.

The following sections will in detail describe the different utilities we use to inflict this CPU behaviour, and how we wrap the different tokens of predictable executions in a deterministicly looped pattern to be used in later analysis, thus relating the CPU behaviour to the time domain. 
Additionally, we will note our expectations, being a description of the expected impact our tests should have on the acoustic fingerprint.

\section{CPU load}
Our first choise of distinguisable CPU activity is in the form of a CPU burn utility. 
The idea is that when no programs are running, save the operating system, the activity level of the CPU us low. 
However, if the user executes a program that will make all cores on the CPU work at close to their full capacity, the internal activity of the CPU will change drastically as a consequence of the increased load.

To achieve this, we installed the cpuburn collection which can be installed using the debian package manager using
apt-get install cpuload. 

To be able to relate this to the time domain, we will execute the following sequence.

\begin{lstlisting}[language=BASH, caption={CPU Burn Utility}]
for i in {1..3}
do
	# burn all cores for 1 second
	sleep 1
	# stop burn on all cores
	sleep 1
done
\end{lstlisting}

This simple loop will let us search for distinct one second intervals in the acoustic fingerprints, as the CPU will operate at close to full capacity, then sleep for a second each, representing the heavy load state and the idle state.
By recoring whilest executing this utility we hope to be able to distinguish between the two states, and to be able to observe a repeating pattern with a period of \(1\) second.

\section{Microinstructions}
Write about the nop mem mul add loop util.
The implementation details for the ARM and x86 architectures

\subsection{Memory Access and Predictable Cache Miss}

\section{Decryption}
Write about the decryption util

\section{CPU microinstruction setup}\label{sec:ch4_cpu_microinstruction_setup}
Before jumping at RSA key extraction, we want to verify that we are able to distinguish the audio fingerprint created by a computer repreating microinstructions. 
The idea is that repeating the same microinstruction over a period of time should produce a distinct audio fingerprint identifying that microinstruction. 
However, the fingerprint is heavily dependent on the targeted hardware configuration. 
For this reason, we got our hands on a Lenovo ThinkPad T60p laptop computer, which is fairly similar in terms of how the computer is built and what hardware is used, so we expect there to be a higher probability of observing the suggested phenomenons using this computer.
\todo{Get a Evo N200!!!, see section 3 in paper}

The laptop is running Linux Mint 17, and starting out we compile and run the following program to repeat the microinstructions 

\begin{lstlisting}[language=C, caption={Simple Microinstruction Loop}]
// see http://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
// \lstinputlisting[language=C]{loop_operations.c}
int main() {
	return 0;
}
\end{lstlisting}


\subsection{Looking at microinstructions}\label{sec:ch4_microinstructions}
Initially, we did were repeating the instructions \( NOP\), \( MUL\) and \( ADD\).
As previously mentioned, our sampling rate of \( 96kHz\) limited our ability to observe the frequency spectrum of the signal to frequencies less than \( 48kHz\).
In this interval we were unable to emirically distinguish the spectrums representing the intervals in time corresponding to the different instructions.
This is not surprising, as the original research shows that there is no obvious visible difference in the frequency response of these three instructions in the frequency range we are observing, even on the laptop with the most rich acoustic leakage.\todo{Refer to Figure 7 in the long paper} 

On the other hand, the paper suggests that looking at HLT compared to NOP and MEM should produce a significant distinguisability even in the frequency range we are working with, given that the instructions are executed on an Evo N200 laptop.
The problem with this is that the HLT instruction must be run in kernel space.
For that reason we choose to focus on distinguishing between MEM and NOP, to be able to keep utilizing our simple setup, and avoid the troubles of kernel space programming.
